axis(1, at=1:6, labels=c(1,2,4,8,16,32))
plot(x)
plot(1:10)
?plot
fpath<-getwd()
png(filename="Alldex.png")
plot(x,dex1,type="l",col="green")
lines(x,dex2,type="l",col="red",xlab="number of dimensions (p)", ylab="dY", xaxt="n")
lines(x,dex3,type="l",col="blue")
axis(1, at=1:6, labels=c(1,2,4,8,16,32))
plot(x,dex1,type="l",col="green")
lines(x,dex2,type="l",col="red",xlab="number of dimensions (p)", ylab="dY", xaxt="n")
lines(x,dex3,type="l",col="blue")
axis(1, at=1:6, labels=c(1,2,4,8,16,32))
source('~/Dropbox/1 Private/R/dimensionallity.R', echo=TRUE)
plot(x,dex1,type="l",col="green",xlab="number of dimensions (p)", ylab="dY", xaxt="n",main="maint",sub="subt"")
axis(1, at=1:6, labels=c(1,2,4,8,16,32))
plot(x,dex1,type="l",col="green",xlab="number of dimensions (p)", ylab="dY", xaxt="n",main="maint",sub="subt")
plot(x,dex1,type="l",col="green",xlab="number of dimensions (p)", ylab="dY", xaxt="n",main="Both functions and all experments")
source('~/Dropbox/1 Private/R/dimensionallity.R', echo=TRUE)
data
library(datasets)
data(iris)
?iris
iris
ii
ii <- data.frame(matrix(aperm(iris3, c(1,3,2)), ncol = 4,
dimnames = list(NULL, sub(" L.",".Length",
sub(" W.",".Width", dni3[[2]])))),
Species = gl(3, 50, labels = sub("S", "s", sub("V", "v", dni3[[3]]))))
all.equal(ii, iris) # TRUE
dni3 <- dimnames(iris3)
ii <- data.frame(matrix(aperm(iris3, c(1,3,2)), ncol = 4,
dimnames = list(NULL, sub(" L.",".Length",
sub(" W.",".Width", dni3[[2]])))),
Species = gl(3, 50, labels = sub("S", "s", sub("V", "v", dni3[[3]]))))
all.equal(ii, iris) # TRUE
ii
ii==iris
?df
subset(df,&Species="virginica")
subset(df,$Species="virginica")
subset(df,Species="virginica")
subset(df,Species=="virginica")
subset(iris,Species=="virginica")
colMeans(subset(iris,Species=="virginica"))
colMeans(subset(iris,Species=="virginica",dims=3))
colMeans(subset(iris,Species=="virginica",dims=4))
colMeans(subset(iris,Species=="virginica",dims=2))
iris{1:4}
iris[1:4]
colMeans(subset(iris[1:4],Species=="virginica",dims=2))
subset(iris,Species=="virginica")
ss<-subset(iris,Species=="virginica")
colMeans(ss[1:4])
data(mtcars)
?mtcars
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(mtcars, cyl, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
mtcars
lapply(mtcars, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$hp, mtcars$cyl, mean)
209.21429 -82.63636
debug(ls)
ls
?gl
gl(3,4)
gl(3,4,5)
?str
source('~/Dropbox/1 Private/R/dimensionallity.R', echo=TRUE)
source('~/Dropbox/1 Private/R/dimensionallity.R', echo=TRUE)
summary(lm.model)
source('~/Dropbox/1 Private/R/dimensionallity.R', echo=TRUE)
?table
table(x,dexsq1)
data
table(x,dexsq1)
test<-c(x,dexsq1)
test
matrix(c,dexsq1)
?matrix
source('~/.active-rstudio-document', echo=TRUE)
source('~/Dropbox/1 Private/R/Fundamentals/testFDA.R', echo=TRUE)
# set the pseudo-random function so the results becomes reproducible
set.seed(123)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x+sin(x)))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
# set the pseudo-random function so the results becomes reproducible
set.seed(123)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x+sin(x)))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
getwd()
olddir
ls()
old.dir
setwd(/Users/jeroenvos/Dropbox/1 Private/R/Fundamentals)
setwd("/Users/jeroenvos/Dropbox/1 Private/R/Fundamentals")
getwd()
source('~/Dropbox/1 Private/R/Fundamentals/testFDA.R', echo=TRUE)
# set the pseudo-random function so the results becomes reproducible
set.seed(123)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x+sin(x)))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
# set the pseudo-random function so the results becomes reproducible
set.seed(123)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x+sin(x)))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
ls()
rm(list = ls())
ls()
old.dir
getwd
# set the pseudo-random function so the results becomes reproducible
set.seed(123)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x+sin(x)))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
# set the pseudo-random function so the results becomes reproducible
set.seed(3452)
# Number of points per sample
n <- 10
x <- 1:n
# Number of samples
N <- 100
# Formula constants
b0 <- 8
b1 <- 0.5
b2 <- 2
y <- b0 + b1 * x^2 + b2 * sin(x^2)
# Generate the random lines:
sigma <- 5
# Matrix: rows corresponds to y values, colomns to samples
data <- sapply(1:N, function(r) y + rnorm(x, 0, sigma))
dimnames(data) <- list(rownames(data, do.NULL = FALSE, prefix = "x = "),
colnames(data, do.NULL = FALSE, prefix = "sample "))
print(data)
write.csv(data, "data.csv", row.names=TRUE)
# variance
getSolution <- function(m) {
predictions <- sapply(1:N, function(i) predict(getModel(m, data[, i])))
meanPrediction <- rowMeans(predictions)
squaredBias <- mean((y - meanPrediction)^2)
variance <- mean(rowMeans(sapply(1:N, function(i) (predictions[,i] - meanPrediction)^2)))
meanSquaredError <- squaredBias + variance
return(c(squaredBias, variance, meanSquaredError))
}
getModel <- function(m, yR) {
# Models
if(m == 1) {
# linear
return(lm(yR ~ x))
} else if(m == 2) {
# quadratic
return(lm(yR ~ poly(x, 2, raw = TRUE)))
} else if(m == 3) {
# cubic
return(lm(yR ~ poly(x, 3, raw = TRUE)))
}
}
draw <- function(m) {
# Create a graph from the sample
plot(x, y, type = "l", col = "black")
colors = rainbow(N)
for (i in 1:N) {
# Random y values
yR = data[, i]
# Add the random plots to the graph
points(x, yR, col = colors[i], pch = 20)
model = getModel(m, yR)
#ysample = ls$coefficient[1] + ls$coefficient[2]*x
lines(x, predict(model), col=colors[i])
}
# Redraw the original formula to have it on the foreground
lines(x, y, col = "black", lwd = 3)
}
result = rbind(
getSolution(1),
getSolution(2),
getSolution(3)
)
rownames(result) <- c('Linear', 'Squared', 'Cubic')
colnames(result) <- c('squaredBias', 'variance', 'mse')
print(result)
data
?predict
source('~/.active-rstudio-document')
gtwd()
getwd()
source('~/Dropbox/1 Private/GITHUB/BikeSharingDemand/BikeSharingPrediction.R', echo=TRUE)
getwd()
source('~/Dropbox/1 Private/GITHUB/BikeSharingDemand/BikeSharingPrediction.R', echo=TRUE)
traindata
traindata[[1]][1:10]
?read.csv
source('~/Dropbox/1 Private/GITHUB/BikeSharingDemand/BikeSharingPrediction.R', echo=TRUE)
traindata[[1]][1:10]
traindata[[$datetime]][1:10]
testdata$dattime
testdata$datetime
?yR
??yR
